### 规则表达式 (regular expression) 
一套规则,用来检索、替换字符串, 速度很快

---

### 声明方式

##### 字面量
```
const str = "123456"
let reg = /123/      123就是规则,且是连续的
console.log(reg.test(str))  //true
 ```
 
##### 构造函数声明
```
let reg1 = new RegExp("134")   "" 里面就是规则
```

---

### 元字符
```
\ 转义符

\d 数字 0-9
\D 非数字
\s 空格
\S 非空格
\w 字符(数字/字母/ _)
\W 非\w 所匹配的范围
\b 单词边界,就是指单词和空格之间的位置
    (单词边界,单词起始,结束,连词符)
    
. 除了换行符(\n \r)之外的所有字符
^ 字符串起始
$ 字符串结束

没什么用的
\t 水平制表符Tab
\v 垂直制表符
\f 换页符
\n 换行符
\r 回车符
```
---

#### { } 量词
```
格式: {a,b} 不能有任何空格
或者 {a,} 至少a个
或者 {,b} 最多b个
```
##### 贪婪非贪婪
```
{a,b}
默认是贪婪的,也就是尽可能多的匹配

后边加上 ? 变成非贪婪

```
#### + 
至少一个 等价于{1,}

#### * 
零次或者多次 等价于{0,}

#### ?
? 前面没有量词的时候,表示零次或一次,等价于{0,1}

---

### 标识符
i  ignore 忽略大小写
```
let str = "HaoNan"
let reg = 
```

g  global 全局标识符 不能乱用   //改变lastIndex
```
let str = "132123"
let reg = /\d/g     //检索全部数字

reg进行全局检索过后,reg.lastIndex 的值就会变成str的str的序号,
   下次再次判断时就会是false,并初始lastIndex的值


```
m 换行匹配 
```
let str = "hao\nnan"
let reg = /^n/m 
reg.test(str)  //true
```
---

### 子集  ( )
- 被括号括起来的部分属于一个整体
#### 正则断言
- 子集默认会被捕获,并被保存下来,以便以后使用($1抓取) //捕获匹配
- 不捕获匹配:(?: 规则) 
- 正向肯定预查//先行断言 (?= 规则1|规则2) : 当满足=后边的规则时,才进行匹配 
- 正向否定预查 (?! 规则)
```
haonan123
haonan345
haonan456
/haonan(?=123)/
/haonan(?=123|345)/
```

- (?<=规则) 反向肯定预查
- (?<!规则) 反向否定预查
```
123haonan
234haonan
/(?<=123|234)haonan/
```
捕获,$1提取
```
let str = "浩南帅逼"
let reg = /(浩南)(帅逼)/
str.repalce(reg,"$2$1")
 //帅逼浩南
```
提取相同的部分
```
let str = '111122223333'
let reg = /(\d)\1/g            转义1,在有子集出现的情况
console.log(str.match(reg))  
=>   ["11","11","22","22","33","33"]

let reg = /(\d)\1+/g
=>   ["1111","2222","3333"]
```
---

### 范围词
#### [ ]
范围词里面所有字符串都是或者关系
```
[0-9]  
[a-zA-Z]

```
#### 中文
```
[\u4e00 - \u9fa5]
```

#### |
或者 符号,左边所有或者右边所有

#### [^ ]
^出现在[ ]里就是非的意思

---

### 正则断言





































